{
  "version": 3,
  "sources": ["../../sturdy-websocket/src/index.ts", "../../es5-ext/global.js", "../../websocket/package.json", "../../websocket/lib/version.js", "../../websocket/lib/browser.js", "../../alchemy-sdk/src/internal/websocket-backfiller.ts", "../../alchemy-sdk/src/api/alchemy-websocket-provider.ts"],
  "sourcesContent": ["export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n", "var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n", "{\n  \"name\": \"websocket\",\n  \"description\": \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\n  \"keywords\": [\n    \"websocket\",\n    \"websockets\",\n    \"socket\",\n    \"networking\",\n    \"comet\",\n    \"push\",\n    \"RFC-6455\",\n    \"realtime\",\n    \"server\",\n    \"client\"\n  ],\n  \"author\": \"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\",\n  \"contributors\": [\n    \"IÃ±aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"\n  ],\n  \"version\": \"1.0.35\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/theturtle32/WebSocket-Node.git\"\n  },\n  \"homepage\": \"https://github.com/theturtle32/WebSocket-Node\",\n  \"engines\": {\n    \"node\": \">=4.0.0\"\n  },\n  \"dependencies\": {\n    \"bufferutil\": \"^4.0.1\",\n    \"debug\": \"^2.2.0\",\n    \"es5-ext\": \"^0.10.63\",\n    \"typedarray-to-buffer\": \"^3.1.5\",\n    \"utf-8-validate\": \"^5.0.2\",\n    \"yaeti\": \"^0.0.6\"\n  },\n  \"devDependencies\": {\n    \"buffer-equal\": \"^1.0.0\",\n    \"gulp\": \"^4.0.2\",\n    \"gulp-jshint\": \"^2.0.4\",\n    \"jshint-stylish\": \"^2.2.1\",\n    \"jshint\": \"^2.0.0\",\n    \"tape\": \"^4.9.1\"\n  },\n  \"config\": {\n    \"verbose\": false\n  },\n  \"scripts\": {\n    \"test\": \"tape test/unit/*.js\",\n    \"gulp\": \"gulp\"\n  },\n  \"main\": \"index\",\n  \"directories\": {\n    \"lib\": \"./lib\"\n  },\n  \"browser\": \"lib/browser.js\",\n  \"license\": \"Apache-2.0\"\n}\n", "module.exports = require('../package.json').version;\n", "var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n", "import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: handle errors\n    const blockHeads = await this.provider.sendBatch(batchParts);\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n", "import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    return this.sendBatchConcurrently(payload);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          const { result } = (message as SubscriptionEvent<unknown>).params;\n          this.emitEvent(virtualId, result);\n        }\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    this.emitEvent(virtualId, result);\n  }\n\n  private emitEvent<T>(virtualId: string, result: T): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<unknown[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\ninterface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,QAAM,iCACF;AACJ,QAAM,yCACF;AAEJ,QAAAA;;MAAA,WAAA;AAkDI,iBAAAA,iBACoB,KAChB,oBACA,SAAqB;AAArB,cAAA,YAAA,QAAA;AAAA,sBAAA,CAAA;UAAqB;AAFL,eAAA,MAAA;AAjCb,eAAA,UAAgD;AAChD,eAAA,UAA2C;AAC3C,eAAA,YAAoD;AACpD,eAAA,SAA0C;AAC1C,eAAA,SAA2D;AAC3D,eAAA,WAA4C;AACnC,eAAA,aAAaA,iBAAgB;AAC7B,eAAA,OAAOA,iBAAgB;AACvB,eAAA,UAAUA,iBAAgB;AAC1B,eAAA,SAASA,iBAAgB;AAKjC,eAAA,gBAAgB;AAChB,eAAA,WAAW;AACX,eAAA,gBAAuB,CAAA;AACvB,eAAA,gBAAwB;AACxB,eAAA,iBAAiB;AAIjB,eAAA,sBAAsB;AACtB,eAAA,oBAAoB;AACX,eAAA,YAAgC,CAAA;AAa7C,cACI,sBAAsB,QACtB,OAAO,uBAAuB,YAC9B,MAAM,QAAQ,kBAAkB,GAClC;AACE,iBAAK,YAAY;iBACd;AACH,sBAAU;;AAEd,eAAK,UAAU,oBAAoB,OAAO;AAC1C,cAAI,CAAC,KAAK,QAAQ,eAAe;AAC7B,gBAAI,OAAO,cAAc,aAAa;AAClC,mBAAK,QAAQ,gBAAgB;mBAC1B;AACH,oBAAM,IAAI,MACN,iFACwC;;;AAIpD,eAAK,iBAAgB;QACzB;AAEA,eAAA,eAAWA,iBAAA,WAAA,cAAU;eAArB,WAAA;AACI,mBAAO,KAAK,sBAAsB;UACtC;eAEA,SAAsB,YAAsB;AACxC,iBAAK,qBAAqB;AAC1B,gBAAI,KAAK,IAAI;AACT,mBAAK,GAAG,aAAa;;UAE7B;;;;AAEA,eAAA,eAAWA,iBAAA,WAAA,kBAAc;eAAzB,WAAA;AACI,gBAAI,MAAM,KAAK,KAAK,KAAK,GAAG,iBAAiB;AAC7C,gBAAI,mBAAmB;AACvB,iBAAK,cAAc,QAAQ,SAAA,MAAI;AAC3B,kBAAM,aAAa,kBAAkB,IAAI;AACzC,kBAAI,cAAc,MAAM;AACpB,uBAAO;qBACJ;AACH,mCAAmB;;YAE3B,CAAC;AACD,gBAAI,kBAAkB;AAClB,mBAAK,SACD,uGACoD;;AAG5D,mBAAO;UACX;;;;AAEA,eAAA,eAAWA,iBAAA,WAAA,cAAU;eAArB,WAAA;AACI,mBAAO,KAAK,KAAK,KAAK,GAAG,aAAa,KAAK;UAC/C;;;;AAEA,eAAA,eAAWA,iBAAA,WAAA,YAAQ;eAAnB,WAAA;AACI,mBAAO,KAAK,KAAK,KAAK,GAAG,WAAW,KAAK;UAC7C;;;;AAEA,eAAA,eAAWA,iBAAA,WAAA,cAAU;eAArB,WAAA;AACI,mBAAO,KAAK,WAAWA,iBAAgB,SAASA,iBAAgB;UACpE;;;;AAEO,QAAAA,iBAAA,UAAA,QAAP,SAAa,MAAe,QAAe;AACvC,eAAK,cAAc,MAAM,MAAM;AAC/B,eAAK,SAAQ;AACb,eAAK,SAAS,yCAAyC;QAC3D;AAEO,QAAAA,iBAAA,UAAA,OAAP,SAAY,MAAS;AACjB,cAAI,KAAK,UAAU;AACf,kBAAM,IAAI,MAAM,kDAAkD;qBAC3D,KAAK,MAAM,KAAK,GAAG,eAAe,KAAK,MAAM;AACpD,iBAAK,GAAG,KAAK,IAAI;iBACd;AACH,iBAAK,cAAc,KAAK,IAAI;;QAEpC;AAEO,QAAAA,iBAAA,UAAA,YAAP,WAAA;AACI,cAAI,KAAK,UAAU;AACf,kBAAM,IAAI,MACN,gEAAgE;;AAGxE,eAAK,cAAc,KAAM,6BAA6B;AACtD,eAAK,YAAY,MAAS;QAC9B;AAUO,QAAAA,iBAAA,UAAA,mBAAP,SACI,MACA,UAA4C;AAE5C,cAAI,CAAC,KAAK,UAAU,IAAI,GAAG;AACvB,iBAAK,UAAU,IAAI,IAAI,CAAA;;AAE3B,eAAK,UAAU,IAAI,EAAE,KAAK,QAAQ;QACtC;AAEO,QAAAA,iBAAA,UAAA,gBAAP,SAAqB,OAAY;AAC7B,iBAAO,KAAK,oBAAoB,MAAM,MAAM,KAAK;QACrD;AAUO,QAAAA,iBAAA,UAAA,sBAAP,SACI,MACA,UAA4C;AAE5C,cAAI,KAAK,UAAU,IAAI,GAAG;AACtB,iBAAK,UAAU,IAAI,IAAI,KAAK,UAAU,IAAI,EAAE,OACxC,SAAA,GAAC;AAAI,qBAAA,MAAM;YAAN,CAAc;;QAG/B;AAEQ,QAAAA,iBAAA,UAAA,mBAAR,WAAA;AAAA,cAAA,QAAA;AACI,cAAI,KAAK,UAAU;AACf;;AAEE,cAAA,KAAA,KAAA,SAAE,iBAAA,GAAA,gBAAgB,gBAAA,GAAA;AACxB,eAAK,SAAS,8BAA4B,KAAK,MAAG,GAAG;AACrD,cAAM,KAAgB,IAAI,cAAc,KAAK,KAAK,KAAK,SAAS;AAChE,aAAG,UAAU,SAAA,OAAK;AAAI,mBAAA,MAAK,YAAY,KAAK;UAAtB;AACtB,aAAG,UAAU,SAAA,OAAK;AAAI,mBAAA,MAAK,YAAY,KAAK;UAAtB;AACtB,aAAG,YAAY,SAAA,OAAK;AAAI,mBAAA,MAAK,cAAc,KAAK;UAAxB;AACxB,aAAG,SAAS,SAAA,OAAK;AAAI,mBAAA,MAAK,WAAW,KAAK;UAArB;AACrB,eAAK,mBAAmB,WAAW,WAAA;AAG/B,kBAAK,oBAAmB;AACxB,kBAAK,cAAa;AAClB,kBAAK,YAAY,MAAS;UAC9B,GAAG,cAAc;AACjB,eAAK,KAAK;QACd;AAEQ,QAAAA,iBAAA,UAAA,aAAR,SAAmB,OAAY;AAA/B,cAAA,QAAA;AACI,cAAI,CAAC,KAAK,MAAM,KAAK,UAAU;AAC3B;;AAEI,cAAA,oBAAA,KAAA,QAAA;AACR,eAAK,SAAS,mBAAmB;AACjC,cAAI,KAAK,sBAAsB,MAAM;AACjC,iBAAK,GAAG,aAAa,KAAK;iBACvB;AACH,iBAAK,qBAAqB,KAAK,GAAG;;AAEtC,eAAK,oBAAmB;AACxB,cAAI,KAAK,eAAe;AACpB,iBAAK,oBAAoB,UAAU,KAAK;iBACrC;AACH,iBAAK,oBAAoB,QAAQ,KAAK;AACtC,iBAAK,gBAAgB;;AAEzB,eAAK,cAAc,QAAQ,SAAA,SAAO;AAAI,mBAAA,MAAK,KAAK,OAAO;UAAjB,CAAkB;AACxD,eAAK,gBAAgB,CAAA;AACrB,eAAK,oBAAoB,WAAW,WAAA;AAChC,kBAAK,qBAAoB;AACzB,kBAAK,gBAAgB;AACrB,kBAAK,iBAAiB;AACtB,gBAAM,WAAY,oBAAoB,MAAQ;AAC9C,kBAAK,SACD,iCAA+B,WAAQ,2CACX;UAEpC,GAAG,iBAAiB;QACxB;AAEQ,QAAAA,iBAAA,UAAA,gBAAR,SAAsB,OAAmB;AACrC,cAAI,KAAK,UAAU;AACf;;AAEJ,eAAK,oBAAoB,WAAW,KAAK;QAC7C;AAEQ,QAAAA,iBAAA,UAAA,cAAR,SAAoB,OAA6B;AAAjD,cAAA,QAAA;AACI,cAAI,KAAK,UAAU;AACf;;AAEE,cAAA,KAAA,KAAA,SAAE,uBAAA,GAAA,sBAAsB,kBAAA,GAAA;AAC9B,eAAK,oBAAmB;AACxB,eAAK,qBAAoB;AACzB,cAAI,KAAK,IAAI;AACT,iBAAK,sBAAsB,KAAK,GAAG;AACnC,iBAAK,oBAAoB,KAAK,GAAG;AACjC,iBAAK,cAAa;;AAEtB,eAAK,oBAAoB,QAAQ,KAAK;AACtC,cAAI,KAAK,kBAAkB,sBAAsB;AAC7C,iBAAK,iBACD,OACA,KAAK,kCAAiC,CAAE;AAE5C;;AAEJ,cAAM,gBAAgB,CAAC,SAAS,gBAAgB,KAAK;AACrD,cAAI,OAAO,kBAAkB,WAAW;AACpC,iBAAK,oBACD,eACA,OACA,8BAA8B;iBAE/B;AACH,0BAAc,KAAK,SAAA,uBAAqB;AACpC,kBAAI,MAAK,UAAU;AACf;;AAEJ,oBAAK,oBACD,uBACA,OACA,sCAAsC;YAE9C,CAAC;;QAET;AAEQ,QAAAA,iBAAA,UAAA,cAAR,SAAoB,OAAY;AAC5B,eAAK,oBAAoB,SAAS,KAAK;AACvC,eAAK,SAAS,iCAAiC;QACnD;AAEQ,QAAAA,iBAAA,UAAA,sBAAR,SACI,eACA,OACA,cAAoB;AAEpB,cAAI,eAAe;AACf,iBAAK,sBAAqB;iBACvB;AACH,iBAAK,iBAAiB,OAAO,YAAY;;QAEjD;AAEQ,QAAAA,iBAAA,UAAA,wBAAR,WAAA;AAAA,cAAA,QAAA;AACU,cAAA,KAAA,KAAA,SACF,oBAAA,GAAA,mBACA,oBAAA,GAAA,mBACA,yBAAA,GAAA;AAEJ,eAAK;AACL,cAAM,YAAY,KAAK;AACvB,eAAK,gBAAgB,KAAK,IACtB,mBACA,KAAK,IACD,KAAK,gBAAgB,wBACrB,iBAAiB,CACpB;AAEL,qBAAW,WAAA;AAAM,mBAAA,MAAK,iBAAgB;UAArB,GAAyB,SAAS;AACnD,cAAM,mBAAoB,YAAY,MAAQ;AAC9C,eAAK,SACD,yCAAuC,mBAAgB,WAAW;QAE1E;AAEQ,QAAAA,iBAAA,UAAA,mBAAR,SACI,OACA,aAAmB;AAEnB,eAAK,SAAS,WAAW;AACzB,eAAK,SAAQ;AACb,cAAI,OAAO;AACP,iBAAK,oBAAoB,SAAS,KAAK;;QAE/C;AAEQ,QAAAA,iBAAA,UAAA,WAAR,WAAA;AACI,eAAK,WAAW;AAChB,eAAK,iBAAgB;AACrB,eAAK,gBAAgB,CAAA;AACrB,eAAK,cAAa;QACtB;AAEQ,QAAAA,iBAAA,UAAA,gBAAR,SAAsB,WAAoB,QAAe;AACrD,cAAI,CAAC,KAAK,IAAI;AACV;;AAKJ,eAAK,GAAG,UAAUC;AAClB,eAAK,GAAG,UAAUA;AAClB,eAAK,GAAG,YAAYA;AACpB,eAAK,GAAG,SAASA;AACjB,eAAK,GAAG,MAAM,WAAW,MAAM;AAC/B,eAAK,KAAK;QACd;AAEQ,QAAAD,iBAAA,UAAA,mBAAR,WAAA;AACI,eAAK,oBAAmB;AACxB,eAAK,qBAAoB;QAC7B;AAEQ,QAAAA,iBAAA,UAAA,sBAAR,WAAA;AACI,cAAI,KAAK,oBAAoB,MAAM;AAC/B,yBAAa,KAAK,gBAAgB;AAClC,iBAAK,mBAAmB;;QAEhC;AAEQ,QAAAA,iBAAA,UAAA,uBAAR,WAAA;AACI,cAAI,KAAK,qBAAqB,MAAM;AAChC,yBAAa,KAAK,iBAAiB;AACnC,iBAAK,oBAAoB;;QAEjC;AAEQ,QAAAA,iBAAA,UAAA,sBAAR,SAA4B,MAAc,OAAU;AAApD,cAAA,QAAA;AACI,kBAAQ,MAAM;YACV,KAAK;AACD,kBAAI,KAAK,SAAS;AACd,qBAAK,QAAQ,KAAK;;AAEtB;YACJ,KAAK;AACD,kBAAI,KAAK,SAAS;AACd,qBAAK,QAAQ,KAAK;;AAEtB;YACJ,KAAK;AACD,kBAAI,KAAK,WAAW;AAChB,qBAAK,UAAU,KAAK;;AAExB;YACJ,KAAK;AACD,kBAAI,KAAK,QAAQ;AACb,qBAAK,OAAO,KAAK;;AAErB;YACJ,KAAK;AACD,kBAAI,KAAK,QAAQ;AACb,qBAAK,OAAO,KAAK;;AAErB;YACJ,KAAK;AACD,kBAAI,KAAK,UAAU;AACf,qBAAK,SAAS,KAAK;;AAEvB;;AAER,cAAI,QAAQ,KAAK,WAAW;AACxB,iBAAK,UAAU,IAAI,EACd,MAAK,EACL,QAAQ,SAAA,UAAQ;AAAI,qBAAA,MAAK,aAAa,UAAU,KAAK;YAAjC,CAAkC;;AAE/D,iBAAO,CAAC,SAAS,CAAE,MAAgB;QACvC;AAEQ,QAAAA,iBAAA,UAAA,eAAR,SACI,UACA,OAAY;AAEZ,cAAI,OAAO,aAAa,YAAY;AAChC,qBAAS,KAAK,MAAM,KAAK;iBACtB;AACH,qBAAS,YAAY,KAAK,MAAM,KAAK;;QAE7C;AAEQ,QAAAA,iBAAA,UAAA,WAAR,SAAiB,SAAe;AAC5B,cAAI,KAAK,QAAQ,OAAO;AAEpB,oBAAQ,IAAI,OAAO;;QAE3B;AAEQ,QAAAA,iBAAA,UAAA,oCAAR,WAAA;AACY,cAAA,uBAAA,KAAA,QAAA;AACR,iBAAO,+BAA6B,uBAAoB,MAAI,UACxD,WACA,oBAAoB,IACvB;QACL;AA5buB,QAAAA,iBAAA,kBAAqC;UACxD,mBAAmB;UACnB,gBAAgB;UAChB,OAAO;UACP,mBAAmB;UACnB,mBAAmB;UACnB,sBAAsB,OAAO;UAC7B,wBAAwB;UACxB,iBAAiB,WAAA;AAAM,mBAAA;UAAA;UACvB,eAAe;;AAGI,QAAAA,iBAAA,aAAa;AACb,QAAAA,iBAAA,OAAO;AACP,QAAAA,iBAAA,UAAU;AACV,QAAAA,iBAAA,SAAS;AA8apC,eAAAA;QA9bA;;sBAAqBA;AAgcrB,aAAS,oBAAoB,SAAgB;AACzC,UAAM,SAAc,CAAA;AACpB,aAAO,KAAKA,iBAAgB,eAAe,EAAE,QAAQ,SAAA,KAAG;AACpD,YAAM,QAAS,QAAgB,GAAG;AAClC,eAAO,GAAG,IACN,UAAU,SACHA,iBAAgB,gBAAwB,GAAG,IAC5C;MACd,CAAC;AACD,aAAO;IACX;AAEA,aAAS,kBAAkB,MAAS;AAChC,UAAI,OAAO,SAAS,UAAU;AAE1B,eAAO,IAAI,KAAK;iBACT,gBAAgB,aAAa;AACpC,eAAO,KAAK;iBACL,gBAAgB,MAAM;AAC7B,eAAO,KAAK;aACT;AACH,eAAO;;IAEf;AAEA,aAAS,UAAU,GAAW,GAAS;AACnC,aAAO,MAAM,IAAI,IAAO,IAAC;IAC7B;AAEA,aAASC,QAAI;IAEb;;;;;AChgBA;AAAA;AAAA,QAAI,gBAAgB,WAAY;AAC/B,UAAI,OAAO,SAAS,YAAY,KAAM,QAAO;AAC7C,UAAI,OAAO,WAAW,YAAY,OAAQ,QAAO;AACjD,YAAM,IAAI,MAAM,iCAAiC;AAAA,IAClD;AAEA,WAAO,UAAW,WAAY;AAC7B,UAAI,KAAM,QAAO;AAKjB,UAAI,OAAO,eAAe,YAAY,WAAY,QAAO;AAKzD,UAAI;AACH,eAAO,eAAe,OAAO,WAAW,cAAc;AAAA,UACrD,KAAK,WAAY;AAAE,mBAAO;AAAA,UAAM;AAAA,UAChC,cAAc;AAAA,QACf,CAAC;AAAA,MACF,SAAS,OAAO;AAGf,eAAO,cAAc;AAAA,MACtB;AACA,UAAI;AAEH,YAAI,CAAC,WAAY,QAAO,cAAc;AACtC,eAAO;AAAA,MACR,UAAE;AACD,eAAO,OAAO,UAAU;AAAA,MACzB;AAAA,IACD,EAAG;AAAA;AAAA;;;AClCH;AAAA;AAAA;AAAA,MACE,MAAQ;AAAA,MACR,aAAe;AAAA,MACf,UAAY;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA,QAAU;AAAA,MACV,cAAgB;AAAA,QACd;AAAA,MACF;AAAA,MACA,SAAW;AAAA,MACX,YAAc;AAAA,QACZ,MAAQ;AAAA,QACR,KAAO;AAAA,MACT;AAAA,MACA,UAAY;AAAA,MACZ,SAAW;AAAA,QACT,MAAQ;AAAA,MACV;AAAA,MACA,cAAgB;AAAA,QACd,YAAc;AAAA,QACd,OAAS;AAAA,QACT,WAAW;AAAA,QACX,wBAAwB;AAAA,QACxB,kBAAkB;AAAA,QAClB,OAAS;AAAA,MACX;AAAA,MACA,iBAAmB;AAAA,QACjB,gBAAgB;AAAA,QAChB,MAAQ;AAAA,QACR,eAAe;AAAA,QACf,kBAAkB;AAAA,QAClB,QAAU;AAAA,QACV,MAAQ;AAAA,MACV;AAAA,MACA,QAAU;AAAA,QACR,SAAW;AAAA,MACb;AAAA,MACA,SAAW;AAAA,QACT,MAAQ;AAAA,QACR,MAAQ;AAAA,MACV;AAAA,MACA,MAAQ;AAAA,MACR,aAAe;AAAA,QACb,KAAO;AAAA,MACT;AAAA,MACA,SAAW;AAAA,MACX,SAAW;AAAA,IACb;AAAA;AAAA;;;ACzDA;AAAA;AAAA,WAAO,UAAU,kBAA2B;AAAA;AAAA;;;ACA5C;AAAA;AAAA,QAAI;AACJ,QAAI,OAAO,eAAe,UAAU;AACnC,oBAAc;AAAA,IACf,OAAO;AACN,UAAI;AACH,sBAAc;AAAA,MACf,SAAS,OAAO;AAAA,MAChB,UAAE;AACD,YAAI,CAAC,eAAe,OAAO,WAAW,aAAa;AAAE,wBAAc;AAAA,QAAQ;AAC3E,YAAI,CAAC,aAAa;AAAE,gBAAM,IAAI,MAAM,iCAAiC;AAAA,QAAG;AAAA,MACzE;AAAA,IACD;AAEA,QAAI,kBAAkB,YAAY,aAAa,YAAY;AAC3D,QAAI,oBAAoB;AAMxB,aAAS,aAAa,KAAK,WAAW;AACrC,UAAI;AAEJ,UAAI,WAAW;AACd,0BAAkB,IAAI,gBAAgB,KAAK,SAAS;AAAA,MACrD,OACK;AACJ,0BAAkB,IAAI,gBAAgB,GAAG;AAAA,MAC1C;AASA,aAAO;AAAA,IACR;AACA,QAAI,iBAAiB;AACpB,OAAC,cAAc,QAAQ,WAAW,QAAQ,EAAE,QAAQ,SAAS,MAAM;AAClE,eAAO,eAAe,cAAc,MAAM;AAAA,UACzC,KAAK,WAAW;AAAE,mBAAO,gBAAgB,IAAI;AAAA,UAAG;AAAA,QACjD,CAAC;AAAA,MACF,CAAC;AAAA,IACF;AAKA,WAAO,UAAU;AAAA,MACb,gBAAiB,kBAAkB,eAAe;AAAA,MAClD,WAAiB;AAAA,IACrB;AAAA;AAAA;;;;ACgBA,IAAM,sBAAsB;IAWf,4BAAmB;EAG9B,YAA6B,UAAkC;AAAlC,SAAQ,WAAR;AADrB,SAAiB,oBAAG;;;;;;;;;;EAWtB,oBACJ,aACA,eACA,iBAAuB;;AAEvB,uBAAiB,WAAW;AAC5B,YAAM,gBAAgB,MAAM,KAAK,eAAc;AAC/C,uBAAiB,WAAW;AAI5B,UAAI,cAAc,WAAW,GAAG;AAC9B,eAAO,KAAK,qBACV,KAAK,IAAI,iBAAiB,gBAAgB,KAAK,iBAAiB,IAAI,GACpE,gBAAgB,CAAC;MAEpB;AAKD,YAAM,sBAAsB,QAC1B,cAAc,cAAc,SAAS,CAAC,EAAE,MAAM;AAEhD,YAAM,iBAAiB,gBAAgB,KAAK,oBAAoB;AAChE,UAAI,uBAAuB,gBAAgB;AACzC,eAAO,KAAK,qBAAqB,gBAAgB,gBAAgB,CAAC;MACnE;AAID,YAAM,aAA8B,MAAM,KAAK,cAC7C,aACA,aAAa;AAEf,uBAAiB,WAAW;AAC5B,YAAM,oBAAqC,MAAM,KAAK,qBACpD,sBAAsB,GACtB,gBAAgB,CAAC;AAEnB,uBAAiB,WAAW;AAC5B,aAAO,CAAC,GAAG,YAAY,GAAG,iBAAiB;KAC5C;EAAA;;;;;;;;;EAUK,gBACJ,aACA,QACA,cACA,iBAAuB;;AAEvB,uBAAiB,WAAW;AAC5B,YAAM,gBAAgB,MAAM,KAAK,eAAc;AAC/C,uBAAiB,WAAW;AAI5B,UAAI,aAAa,WAAW,GAAG;AAC7B,eAAO,KAAK,eACV,QACA,KAAK,IAAI,iBAAiB,gBAAgB,KAAK,iBAAiB,IAAI,GACpE,gBAAgB,CAAC;MAEpB;AAKD,YAAM,sBAAsB,QAC1B,aAAa,aAAa,SAAS,CAAC,EAAE,WAAW;AAEnD,YAAM,iBAAiB,gBAAgB,KAAK,oBAAoB;AAChE,UAAI,sBAAsB,gBAAgB;AACxC,eAAO,KAAK,eAAe,QAAQ,gBAAgB,gBAAgB,CAAC;MACrE;AAID,YAAM,iBAAiB,MAAM,KAAK,kBAChC,aACA,YAAY;AAEd,uBAAiB,WAAW;AAI5B,YAAM,cAAc,aACjB,OAAO,SAAO,QAAQ,IAAI,WAAW,IAAI,eAAe,WAAW,EACnE,IAAI,SAAO,OAAA,OAAA,OAAA,OAAA,CAAA,GAAM,GAAG,GAAA,EAAE,SAAS,KAAI,CAAA,CAAG;AAIzC,YAAM,qBACJ,eAAe,gBAAgB,OAAO,oBAClC,QAAQ,aAAa,CAAC,EAAE,WAAW,IACnC,eAAe;AACrB,UAAI,YAAY,MAAM,KAAK,eACzB,QACA,oBACA,gBAAgB,CAAC;AAInB,kBAAY,UAAU,OACpB,SACE,QACC,QAAQ,IAAI,WAAW,IAAI,eAAe,eACzC,QAAQ,IAAI,QAAQ,IAAI,eAAe,SAAS;AAGtD,uBAAiB,WAAW;AAC5B,aAAO,CAAC,GAAG,aAAa,GAAG,SAAS;KACrC;EAAA;;;;;;EAOD,oBAAoB,QAAc;AAChC,SAAK,oBAAoB;;;;;;;EAQb,iBAAc;;AAC1B,YAAM,iBAAyB,MAAM,KAAK,SAAS,KAAK,iBAAiB;AACzE,aAAO,QAAQ,cAAc;KAC9B;EAAA;;;;;;;;EASa,qBACZ,oBACA,kBAAwB;;AAExB,UAAI,sBAAsB,kBAAkB;AAC1C,eAAO,CAAA;MACR;AACD,YAAM,aAA0B,CAAA;AAChC,eAAS,IAAI,oBAAoB,IAAI,kBAAkB,KAAK;AAC1D,mBAAW,KAAK;UACd,QAAQ;UACR,QAAQ,CAAC,MAAM,CAAC,GAAG,KAAK;QACzB,CAAA;MACF;AAGD,YAAM,aAAa,MAAM,KAAK,SAAS,UAAU,UAAU;AAC3D,aAAO,WAAW,IAAI,eAAe;KACtC;EAAA;;;;;;EAOa,cACZ,aACA,eAA8B;;AAE9B,YAAM,SAA0B,CAAA;AAGhC,eAAS,IAAI,cAAc,SAAS,GAAG,KAAK,GAAG,KAAK;AAClD,cAAM,WAAW,cAAc,CAAC;AAChC,cAAM,YAAY,MAAM,KAAK,iBAAiB,QAAQ,SAAS,MAAM,CAAC;AACtE,yBAAiB,WAAW;AAG5B,YAAI,SAAS,SAAS,UAAU,MAAM;AACpC;QACD;AAED,eAAO,KAAK,gBAAgB,SAAS,CAAC;MACvC;AACD,aAAO,OAAO,QAAO;KACtB;EAAA;;;;;;;EAQa,iBAAiB,aAAmB;;AAChD,aAAO,KAAK,SAAS,KAAK,wBAAwB;QAChD,MAAM,WAAW;QACjB;MACD,CAAA;KACF;EAAA;;;;;;;;;;;EAYa,kBACZ,aACA,cAAyB;;AAIzB,UAAI,YAAY,MAAM,KAAK,iBACzB,QAAQ,aAAa,aAAa,SAAS,CAAC,EAAE,WAAW,CAAC;AAE5D,uBAAiB,WAAW;AAC5B,eAAS,IAAI,aAAa,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,cAAM,SAAS,aAAa,CAAC;AAI7B,YAAI,OAAO,gBAAgB,UAAU,QAAQ;AAC3C,sBAAY,MAAM,KAAK,iBAAiB,QAAQ,OAAO,WAAW,CAAC;QACpE;AAID,YAAI,OAAO,cAAc,UAAU,MAAM;AACvC,iBAAO;YACL,aAAa,QAAQ,OAAO,WAAW;YACvC,UAAU,QAAQ,OAAO,QAAQ;;QAEpC;MACF;AACD,aAAO;QACL,aAAa,OAAO;QACpB,UAAU,OAAO;;KAEpB;EAAA;;;;;;;EAOiB,eAChB,QACA,oBACA,kBAAwB;;AAExB,UAAI,sBAAsB,kBAAkB;AAC1C,eAAO,CAAA;MACR;AACD,YAAM,cAAW,OAAA,OAAA,OAAA,OAAA,CAAA,GACZ,MAAM,GAAA,EACT,WAAW,MAAM,kBAAkB,GACnC,SAAS,MAAM,mBAAmB,CAAC,EAAC,CAAA;AAEtC,aAAO,KAAK,SAAS,KAAK,eAAe,CAAC,WAAW,CAAC;KACvD;EAAA;AACF;AAED,SAAS,gBAAgB,MAAe;AACtC,QAAM,SAAM,OAAA,OAAA,CAAA,GAA4C,IAAI;AAC5D,SAAO,OAAO;AACd,SAAO,OAAO;AACd,SAAO,OAAO;AACd,SAAO;AACT;AAEM,SAAU,eAAe,QAAuB;AACpD,SAAO,OAAO,QAAQ,WAAS,MAAM,IAAI;AAC3C;AAEM,SAAU,WAAW,QAAmB;AAC5C,SAAO,OAAO,QAAQ,WAAS,GAAG,MAAM,SAAS,IAAI,MAAM,QAAQ,EAAE;AACvE;AAEA,SAAS,OAAU,OAAY,QAAwB;AACrD,QAAM,WAAqB,oBAAI,IAAG;AAClC,QAAM,SAAc,CAAA;AACpB,QAAM,QAAQ,UAAO;AACnB,UAAM,MAAM,OAAO,IAAI;AACvB,QAAI,CAAC,SAAS,IAAI,GAAG,GAAG;AACtB,eAAS,IAAI,GAAG;AAChB,aAAO,KAAK,IAAI;IACjB;EACH,CAAC;AACD,SAAO;AACT;AAEA,IAAM,YAAY,IAAI,MAAM,WAAW;AACjC,SAAU,iBAAiB,aAA0B;AACzD,MAAI,YAAW,GAAI;AACjB,UAAM;EACP;AACH;AC5VA,IAAM,qBAAqB;AAC3B,IAAM,sBAAsB;AAC5B,IAAM,mBAAmB;AACzB,IAAM,mBAAmB;AAWzB,IAAM,6BAA6B;AAU7B,IAAO,2BAAP,cACI,kBAAiB;;EAyBzB,YAAY,QAAuB,eAAmB;;AAEpD,UAAM,SAAS,gBAAgB,UAAU,OAAO,MAAM;AAGtD,UAAM,iBAAiB,gBAAgB,kBAAkB,OAAO,OAAO;AACvE,UAAM,aAAa,gBAAgB,yBACjC,gBACA,QACA,KAAK;AAGP,UAAM,WAAW,eAAe,OAAO;AAGvC,UAAM,KAAK,IAAI,wBAAAC,SAAgB,KAAA,OAAO,SAAG,QAAA,OAAA,SAAA,KAAI,WAAW,KAAK,UAAU;MACrE,eAAe,kBAAA,QAAA,kBAAa,SAAb,gBAAiB,wBAAuB;IACxD,CAAA;AAKD,UAAM,gBAAgB,cAAc,cAAc;AAClD,UAAM,IAAW,aAAa;AA7ChC,SAAO,UAAuB,CAAA;AAUb,SAAA,2BACf,oBAAI,IAAG;AAEQ,SAAA,yBAA8C,oBAAI,IAAG;AAiZ9D,SAAA,gBAAgB,CAAC,UAA6B;AACpD,YAAM,UAA4B,KAAK,MAAM,MAAM,IAAI;AACvD,UAAI,CAAC,oBAAoB,OAAO,GAAG;AACjC;MACD;AACD,YAAM,aAAa,QAAQ,OAAO;AAClC,YAAM,YAAY,KAAK,uBAAuB,IAAI,UAAU;AAC5D,UAAI,CAAC,WAAW;AACd;MACD;AACD,YAAM,eAAe,KAAK,yBAAyB,IAAI,SAAS;AAChE,UAAI,aAAa,WAAW,iBAAiB;AAC3C;MACD;AAED,cAAQ,aAAa,OAAO,CAAC,GAAC;QAC5B,KAAK,YAAY;AACf,gBAAM,uBAAuB;AAC7B,gBAAM,kBAAkB;AACxB,gBAAM,EAAE,eAAe,eAAc,IAAK;AAC1C,gBAAM,EAAE,OAAM,IAAK,gBAAgB;AACnC,cAAI,eAAe;AACjB,sCAA0B,gBAAgB,MAAM;UACjD,WAAU,eAAe,WAAW;AAGnC,iBAAK,qBAAqB,WAAW,QAAQ,sBAAsB;UACpE,OAAM;AAEL,iBAAK,cAAc,WAAW,QAAQ,sBAAsB;UAC7D;AACD;QACD;QACD,KAAK,QAAQ;AACX,gBAAM,mBAAmB;AACzB,gBAAM,cAAc;AACpB,gBAAM,EAAE,eAAe,eAAc,IAAK;AAC1C,gBAAM,EAAE,OAAM,IAAK,YAAY;AAC/B,cAAI,eAAe;AACjB,kCAAsB,gBAAgB,MAAM;UAC7C,WAAU,cAAc,YAAY;AACnC,iBAAK,qBAAqB,WAAW,QAAQ,kBAAkB;UAChE,OAAM;AACL,iBAAK,cAAc,WAAW,QAAQ,kBAAkB;UACzD;AACD;QACD;QACD;AACE,cAAI,eAAe,WAAW;AAG5B,kBAAM,EAAE,OAAM,IAAM,QAAuC;AAC3D,iBAAK,UAAU,WAAW,MAAM;UACjC;MACJ;IACH;AAaQ,SAAY,eAAG,MAAK;AAC1B,WAAK,uBAAuB,MAAK;AACjC,YAAM,EAAE,QAAQ,YAAW,IAAK,gBAAe;AAC/C,WAAK,iBAAiB;AACtB,iBAAW,gBAAgB,KAAK,yBAAyB,OAAM,GAAI;AACjE,cAAM,MAAW,YAAA,MAAA,QAAA,QAAA,aAAA;AACf,cAAI;AACF,kBAAM,KAAK,uBAAuB,aAAa,YAAY;UAC5D,SAAQ,OAAO;AACd,gBAAI,CAAC,YAAW,GAAI;AAClB,sBAAQ,MACN,4BAA4B,aAAa,OAAO,CAAC,CAAC,+CAClD,KAAK;YAER;UACF;SACF,GAAA;MACF;AACD,WAAK,eAAc;IACrB;AAuFQ,SAAwB,2BAAG,MAAK;AACtC,UAAI,KAAK,uBAAuB,MAAM;AACpC,sBAAc,KAAK,mBAAmB;AACtC,aAAK,sBAAsB;MAC5B;AACD,WAAK,eAAc;IACrB;AApiBE,SAAK,SAAS;AAGd,SAAK,aAAa,IAAI,oBAAoB,IAAI;AAC9C,SAAK,mBAAkB;AACvB,SAAK,eAAc;AACnB,SAAK,iBAAiB;;;;;;;;;;;EAYxB,OAAO,WAAW,SAAmB;AACnC,QAAI,OAAO,YAAY,YAAY,WAAW,gBAAgB;AAC5D,aAAO,eAAe,OAAO;IAC9B;AAGD,WAAOC,WAAqB,OAAO;;;;;;;;;;;EAYrC,GAAG,WAA6B,UAAkB;AAChD,WAAO,KAAK,kBAAkB,WAAW,UAAU,KAAK;;;;;;;;;;;;;EAc1D,KAAK,WAA6B,UAAkB;AAClD,WAAO,KAAK,kBAAkB,WAAW,UAAU,IAAI;;;;;;;;;;;EAYzD,IAAI,WAA6B,UAAmB;AAClD,QAAI,eAAe,SAAS,GAAG;AAC7B,aAAO,KAAK,KAAK,WAAW,QAAQ;IACrC,OAAM;AACL,aAAO,MAAM,IAAI,WAAW,QAAQ;IACrC;;;;;;;;;;EAWH,mBAAmB,WAA4B;AAC7C,QAAI,cAAc,UAAa,eAAe,SAAS,GAAG;AACxD,aAAO,KAAK,oBAAoB,SAAS;IAC1C,OAAM;AACL,aAAO,MAAM,mBAAmB,SAAS;IAC1C;;;;;;;;;;EAWH,cAAc,WAA4B;AACxC,QAAI,cAAc,UAAa,eAAe,SAAS,GAAG;AACxD,aAAO,KAAK,eAAe,SAAS;IACrC,OAAM;AACL,aAAO,MAAM,cAAc,SAAS;IACrC;;;;;;;;;;EAWH,UAAU,WAA4B;AACpC,QAAI,cAAc,UAAa,eAAe,SAAS,GAAG;AACxD,aAAO,KAAK,WAAW,SAAS;IACjC,OAAM;AACL,aAAO,MAAM,UAAU,SAAS;IACjC;;;;;;;;;EAUH,kBACE,WACA,UACA,MAAa;AAEb,QAAI,eAAe,SAAS,GAAG;AAC7B,6BAAuB,SAAS;AAChC,YAAM,QAAQ,IAAI,YAChB,mBAAmB,SAAS,GAC5B,UACA,IAAI;AAEN,WAAK,QAAQ,KAAK,KAAK;AACvB,WAAK,YAAY,KAAK;AACtB,aAAO;IACR,OAAM;AACL,aAAO,MAAM,kBAAkB,WAAW,UAAU,IAAI;IACzD;;;;;;;;;;EAWH,YAAY,OAAkB;AAE5B,UAAM,mBAAmB,CAAC,GAAG,qBAAqB,SAAS,QAAQ;AACnE,QAAI,iBAAiB,SAAS,MAAM,IAAI,GAAG;AACzC,WAAK,iBAAiB,KAAK;IAC5B,OAAM;AACL,YAAM,YAAY,KAAK;IACxB;;;;;;;;;;EAWG,WACJ,KACA,OACA,aACA,OAAmB;;AAEnB,UAAI,eAAe,KAAK,QAAQ,GAAG;AAGnC,YAAM,sBAAsB,MAAM,KAAK,eAAc;AAGrD,UAAI,gBAAgB,MAAM;AACxB,uBAAe,QAAQ,IAAI,KAAK,EAAE,KAAK,CAAAC,WAAQ;AAC7C,iBAAO,KAAK,KAAK,iBAAiBA,MAAK;QACzC,CAAC;AACD,aAAK,QAAQ,GAAG,IAAI;MACrB;AACD,YAAM,QAAQ,MAAM;AAGpB,YAAM,iBAAiB,MAAM,QAAQ,IAAI,KAAK;AAC9C,WAAK,yBAAyB,IAAI,OAAO;QACvC;QACA,QAAQ;QACR,QAAQ;QACR;QACA,WAAW;QACX,YAAY;QACZ,YAAY,CAAA;QACZ,eAAe;QACf,gBAAgB,CAAA;MACjB,CAAA;AACD,WAAK,uBAAuB,IAAI,OAAO,KAAK;AAI5C,WAAK,MAAM,KAAK,IAAI,EAAE,KAAK,YAAW;KACvC;EAAA;;;;;;;;;;;;;;EAeD,KAAK,cAAgC,MAAgB;AACnD,QAAI,eAAe,SAAS,GAAG;AAC7B,UAAI,SAAS;AAEb,YAAM,UAA8B,CAAA;AAGpC,YAAM,WAAW,mBAAmB,SAAS;AAE7C,WAAK,UAAU,KAAK,QAAQ,OAAO,WAAQ;AACzC,YAAI,MAAM,QAAQ,UAAU;AAC1B,iBAAO;QACR;AAED,mBAAW,MAAK;AACd,gBAAM,SAAS,MAAM,MAAM,IAAI;WAC9B,CAAC;AAEJ,iBAAS;AAET,YAAI,MAAM,MAAM;AACd,kBAAQ,KAAK,KAAK;AAClB,iBAAO;QACR;AAED,eAAO;MACT,CAAC;AAED,cAAQ,QAAQ,WAAQ;AACtB,aAAK,WAAW,KAAK;MACvB,CAAC;AAED,aAAO;IACR,OAAM;AACL,aAAO,MAAM,KAAK,WAAW,GAAG,IAAI;IACrC;;;EAIG,UAAU,OAAkB;;AAChC,UAAI,SAAS;AACb,YAAM,UAA4B,MAAM,IAAI,CAAC,EAAE,QAAQ,OAAM,MAAM;AACjE,eAAO;UACL;UACA;UACA,SAAS;UACT,IAAI,eAAe,QAAQ;;MAE/B,CAAC;AAED,aAAO,KAAK,sBAAsB,OAAO;KAC1C;EAAA;;EAGD,UAAO;AACL,SAAK,sBAAqB;AAC1B,SAAK,yBAAwB;AAC7B,WAAO,MAAM,QAAO;;;;;;;;EAStB,sBAAmB;AACjB,WAAO,KAAK,WAAW;;;;;;;;;;;;;EAczB,WAAW,OAAkB;AAC3B,QAAI,MAAM,MAAM;AAGhB,QAAI,oBAAoB,SAAS,MAAM,IAAI,GAAG;AAE5C,UACE,KAAK,QAAQ,OAAO,OAAK,oBAAoB,SAAS,EAAE,IAAI,CAAC,EAAE,QAC/D;AACA;MACD;IAEF,WAAU,MAAM,SAAS,MAAM;AAE9B,UAAI,KAAK,QAAQ,OAAO,OAAK,EAAE,SAAS,IAAI,EAAE,QAAQ;AACpD;MACD;AACD,YAAM;IACP,WAAU,KAAK,cAAc,MAAM,KAAK,GAAG;AAE1C;IACD;AAED,UAAM,QAAQ,KAAK,QAAQ,GAAG;AAC9B,QAAI,CAAC,OAAO;AACV;IACD;AAED,WAAO,KAAK,QAAQ,GAAG;AACvB,SAAK,MAAM,KAAK,CAAAC,WAAQ;AACtB,UAAI,CAAC,KAAK,MAAMA,MAAK,GAAG;AACtB;MACD;AACD,aAAO,KAAK,MAAMA,MAAK;AACvB,WAAK,KAAK,KAAK,mBAAmB,CAACA,MAAK,CAAC;IAC3C,CAAC;;;EAIK,qBAAkB;AACxB,SAAK,WAAW,iBAAiB,WAAW,KAAK,aAAa;AAC9D,SAAK,WAAW,iBAAiB,UAAU,KAAK,YAAY;AAC5D,SAAK,WAAW,iBAAiB,QAAQ,KAAK,wBAAwB;;;EAIhE,wBAAqB;AAC3B,SAAK,WAAW,oBAAoB,WAAW,KAAK,aAAa;AACjE,SAAK,WAAW,oBAAoB,UAAU,KAAK,YAAY;AAC/D,SAAK,WAAW,oBAAoB,QAAQ,KAAK,wBAAwB;;;;;;;;;EA4G7D,uBACZ,aACA,cAAiC;;AAEjC,YAAM,EACJ,WACA,QACA,QACA,YACA,gBACA,oBAAmB,IACjB;AACJ,mBAAa,gBAAgB;AAC7B,qBAAe,SAAS;AACxB,UAAI;AACF,cAAM,aAAa,MAAM,KAAK,KAAK,QAAQ,MAAM;AACjD,yBAAiB,WAAW;AAC5B,qBAAa,aAAa;AAC1B,aAAK,uBAAuB,IAAI,YAAY,SAAS;AACrD,gBAAQ,OAAO,CAAC,GAAC;UACf,KAAK,YAAY;AACf,kBAAM,iBAAiB,MAAM,mBAC3B,MACE,YACE,KAAK,WAAW,oBACd,aACA,YACA,mBAAmB,GAErB,gBAAgB,GAEpB,kBACA,MAAM,CAAC,YAAW,CAAE;AAEtB,6BAAiB,WAAW;AAC5B,kBAAM,SAAS,eAAe,CAAC,GAAG,gBAAgB,GAAG,cAAc,CAAC;AACpE,mBAAO,QAAQ,WAAS,KAAK,kBAAkB,WAAW,KAAK,CAAC;AAChE;UACD;UACD,KAAK,QAAQ;AACX,kBAAM,SAAiC,OAAO,CAAC,KAAK,CAAA;AACpD,kBAAM,iBAAiB,MAAM,mBAC3B,MACE,YACE,KAAK,WAAW,gBACd,aACA,QACA,YACA,mBAAmB,GAErB,gBAAgB,GAEpB,kBACA,MAAM,CAAC,YAAW,CAAE;AAEtB,6BAAiB,WAAW;AAC5B,kBAAM,SAAS,WAAW,CAAC,GAAG,gBAAgB,GAAG,cAAc,CAAC;AAChE,mBAAO,QAAQ,WAAS,KAAK,cAAc,WAAW,KAAK,CAAC;AAC5D;UACD;UACD;AACE;QACH;MACF,UAAS;AACR,qBAAa,gBAAgB;AAC7B,uBAAe,SAAS;MACzB;KACF;EAAA;;EAoBO,kBAAkB,WAAmB,QAAqB;AAChE,SAAK,qBAAqB,WAAW,QAAQ,sBAAsB;;;EAI7D,cAAc,WAAmB,QAAiB;AACxD,SAAK,qBAAqB,WAAW,QAAQ,kBAAkB;;;;;;;;;EAUzD,qBACN,WACA,QACA,gBAAqC;AAErC,SAAK,cAAc,WAAW,QAAQ,cAAc;AACpD,SAAK,UAAU,WAAW,MAAM;;EAG1B,UAAa,WAAmB,QAAS;AAC/C,UAAM,eAAe,KAAK,yBAAyB,IAAI,SAAS;AAChE,QAAI,CAAC,cAAc;AACjB;IACD;AACD,SAAK,iBAAiB,cAAc,MAAM;;;EAIpC,cACN,WACA,QACA,gBAAqC;AAErC,UAAM,eAAe,KAAK,yBAAyB,IAAI,SAAS;AAChE,QAAI,CAAC,cAAc;AACjB;IACD;AAID,0BACE,aAAa,YAAU,OAAA,OAAA,CAAA,GAClB,MAAM,GACX,cAAc;;;EAKV,iBACN,cACA,QAAW;AAEX,UAAM,eAAe,KAAK,cAAc,aAAa,KAAK;AAC1D,iBAAa,MAAM;;;;;;;;EASb,iBAAc;AACpB,QAAI,KAAK,uBAAuB,MAAM;AACpC;IACD;AACD,SAAK,sBAAsB,YAAY,MAAW,YAAA,MAAA,QAAA,QAAA,aAAA;AAChD,UAAI;AACF,cAAM,YAAY,KAAK,KAAK,aAAa,GAAG,mBAAmB;MAChE,SAAO,IAAA;AACN,aAAK,WAAW,UAAS;MAC1B;IACH,CAAC,GAAE,kBAAkB;;;;;;;;;;;;EAaT,sBACZ,SAAyB;;AAEzB,aAAO,QAAQ,IAAI,QAAQ,IAAI,SAAO,KAAK,KAAK,IAAI,QAAQ,IAAI,MAAM,CAAC,CAAC;KACzE;EAAA;;EAGO,iBAAiB,OAAkB;AACzC,QAAI,MAAM,SAAS,yCAAyC;AAC1D,YAAM,EAAE,aAAa,WAAW,WAAU,IAAK;AAC/C,WAAK,KAAK,WACR,MAAM,KACN;QACE,oBAAoB;QACpB,EAAE,aAAa,WAAW,WAAU;SAEtC,KAAK,cAAc,KAAK,GACxB,KAAK;IAER,WAAU,MAAM,SAAS,uCAAuC;AAC/D,YAAM,EAAE,WAAW,gBAAgB,WAAU,IAAK;AAClD,WAAK,KAAK,WACR,MAAM,KACN;QACE,oBAAoB;QACpB,EAAE,WAAW,gBAAgB,WAAU;SAEzC,KAAK,cAAc,KAAK,GACxB,KAAK;IAER,WAAU,MAAM,SAAS,SAAS;AACjC,WAAK,KAAK,WACR,SACA,CAAC,UAAU,GACX,KAAK,cAAc,KAAK,GACxB,KAAK;IAER,WAAU,MAAM,SAAS,UAAU;AAClC,WAAK,KAAK,WACR,MAAM,KACN,CAAC,QAAQ,KAAK,WAAW,MAAM,MAAM,CAAC,GACtC,KAAK,cAAc,KAAK,GACxB,KAAK;IAER;;;EAIK,cAAc,OAAkB;AACtC,YAAQ,MAAM,MAAI;MAChB,KAAK;AACH,eAAO,YACL,KAAK,KACH;UACE,QAAQ,oBAAoB;UAC5B,aAAa,MAAM;UACnB,WAAW,MAAM;UACjB,YAAY,MAAM;WAEpB,MAAM;MAEZ,KAAK;AACH,eAAO,YACL,KAAK,KACH;UACE,QAAQ,oBAAoB;UAC5B,WAAW,MAAM;UACjB,gBAAgB,MAAM;UACtB,YAAY,MAAM;WAEpB,MAAM;MAEZ,KAAK;AACH,eAAO,YAAS;AACd,gBAAM,cAAc,UAAU,KAAK,OAAO,MAAM,EAAE,SAAQ;AAC1D,eAAK,SAAS,QAAQ;AACtB,eAAK,KAAK,SAAS,WAAW;QAChC;MACF,KAAK;AACH,eAAO,YAAS;AACd,cAAI,OAAO,WAAW,MAAM;AAC1B,mBAAO,UAAU;UAClB;AACD,eAAK,KAAK,MAAM,QAAQ,KAAK,UAAU,UAAU,MAAM,CAAC;QAC1D;MACF;AACE,cAAM,IAAI,MAAM,yCAAyC;IAC5D;;;;;;;;;;;;;;EAeK,KAAK,WAA6B,UAAmB;AAC3D,QAAI,YAAY,MAAM;AACpB,aAAO,KAAK,mBAAmB,SAAS;IACzC;AAED,UAAM,UAA8B,CAAA;AAEpC,QAAI,QAAQ;AACZ,UAAM,WAAW,mBAAmB,SAAS;AAC7C,SAAK,UAAU,KAAK,QAAQ,OAAO,WAAQ;AACzC,UAAI,MAAM,QAAQ,YAAY,MAAM,YAAY,UAAU;AACxD,eAAO;MACR;AACD,UAAI,OAAO;AACT,eAAO;MACR;AACD,cAAQ;AACR,cAAQ,KAAK,KAAK;AAClB,aAAO;IACT,CAAC;AAED,YAAQ,QAAQ,WAAQ;AACtB,WAAK,WAAW,KAAK;IACvB,CAAC;AAED,WAAO;;;;;;;;;;;;;;EAeD,oBAAoB,WAA2B;AACrD,QAAI,UAA8B,CAAA;AAClC,QAAI,aAAa,MAAM;AACrB,gBAAU,KAAK;AAEf,WAAK,UAAU,CAAA;IAChB,OAAM;AACL,YAAM,WAAW,mBAAmB,SAAS;AAC7C,WAAK,UAAU,KAAK,QAAQ,OAAO,WAAQ;AACzC,YAAI,MAAM,QAAQ,UAAU;AAC1B,iBAAO;QACR;AACD,gBAAQ,KAAK,KAAK;AAClB,eAAO;MACT,CAAC;IACF;AAED,YAAQ,QAAQ,WAAQ;AACtB,WAAK,WAAW,KAAK;IACvB,CAAC;AAED,WAAO;;;;;;;;;;;;;;EAeD,eAAe,WAA4B;AACjD,QAAI,CAAC,WAAW;AACd,aAAO,KAAK,QAAQ;IACrB;AAED,UAAM,WAAW,mBAAmB,SAAS;AAC7C,WAAO,KAAK,QAAQ,OAAO,WAAQ;AACjC,aAAO,MAAM,QAAQ;KACtB,EAAE;;;;;;;;;;;;;;EAeG,WAAW,WAA4B;AAC7C,QAAI,aAAa,MAAM;AACrB,aAAO,KAAK,QAAQ,IAAI,WAAS,MAAM,QAAQ;IAChD;AAED,UAAM,WAAW,mBAAmB,SAAS;AAC7C,WAAO,KAAK,QACT,OAAO,WAAS,MAAM,QAAQ,QAAQ,EACtC,IAAI,WAAS,MAAM,QAAQ;;AAEjC;AAED,SAAS,0BAAuB;AAC9B,SAAO,kBAAiB,IAAK,kBAAqB,eAAe;AACnE;AAEA,SAAS,oBAAiB;AACxB,SACE,OAAO,YAAY,eACnB,WAAW,QACX,QAAQ,YAAY,QACpB,QAAQ,SAAS,QAAQ;AAE7B;AAqCA,SAAS,kBAAe;AACtB,MAAI,YAAY;AAChB,SAAO,EAAE,QAAQ,MAAO,YAAY,MAAO,aAAa,MAAM,UAAS;AACzE;AAGA,IAAM,kBAAkB;AACxB,IAAM,uBAAuB;AAC7B,IAAM,kBAAkB;AAExB,SAAe,mBACb,GACA,YACA,cAA2C,MAAM,MAAI;;AAErD,QAAI,eAAe;AACnB,QAAI,IAAI;AACR,WAAO,MAAM;AACX,UAAI;AACF,eAAO,MAAM,EAAC;MACf,SAAQ,OAAO;AACd;AACA,YAAI,KAAK,cAAc,CAAC,YAAY,KAAK,GAAG;AAC1C,gBAAM;QACP;AACD,cAAM,MAAM,YAAY;AACxB,YAAI,CAAC,YAAY,KAAK,GAAG;AACvB,gBAAM;QACP;AACD,uBACE,iBAAiB,IACb,kBACA,KAAK,IAAI,iBAAiB,uBAAuB,YAAY;MACpE;IACF;GACF;AAAA;AAED,SAAS,MAAM,IAAU;AACvB,SAAO,IAAI,QAAQ,aAAW,WAAW,SAAS,EAAE,CAAC;AACvD;AAEA,SAAS,YAAe,SAAqB,IAAU;AACrD,SAAO,QAAQ,KAAK;IAClB;IACA,IAAI,QAAW,CAAC,GAAG,WACjB,WAAW,MAAM,OAAO,IAAI,MAAM,SAAS,CAAC,GAAG,EAAE,CAAC;EAErD,CAAA;AACH;AAEA,SAAS,uBAAuB,OAAoB;AAClD,SAAO,QAAQ,MAAM,MAAM;AAC7B;AAEA,SAAS,mBAAmB,OAAgB;AAC1C,SAAO,QAAQ,MAAM,WAAW;AAClC;AAEA,SAAS,WACP,SAAyB;AAEzB,SACE,MAAM,QAAQ,OAAO,KACpB,QAAQ,YAAY,SAAU,QAA4B,OAAO;AAEtE;AAEA,SAAS,oBACP,SAAyB;AAEzB,SAAO,CAAC,WAAW,OAAO;AAC5B;AAEA,SAAS,0BACP,YACA,OAAoB;AAEpB,wBAAsB,YAAY,OAAO,sBAAsB;AACjE;AAEA,SAAS,sBACP,YACA,OAAgB;AAEhB,wBAAsB,YAAY,OAAO,kBAAkB;AAC7D;AAMA,SAAS,sBACP,YACA,OACA,gBAAoC;AAEpC,QAAM,qBAAqB,eAAe,KAAK;AAG/C,QAAM,iBAAiB,WAAW,UAChC,OAAK,eAAe,CAAC,IAAI,qBAAqB,0BAA0B;AAE1E,MAAI,mBAAmB,IAAI;AACzB,eAAW,SAAS;EACrB,OAAM;AACL,eAAW,OAAO,GAAG,cAAc;EACpC;AACD,aAAW,KAAK,KAAK;AACvB;",
  "names": ["SturdyWebSocket", "noop", "SturdyWebSocket", "getNetworkFromEthers", "param", "subId"]
}
